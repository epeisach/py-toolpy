# =================================================================
#  Calculate the close contact by the grid method
#  put atom index to each box and only check the distance in the 27 cells.
#  (HY, 2013-08-03 )
# =================================================================
# corrections:
# fix a bug in shift_xyz2unit and reduce box to (-1,0, 1) faster (2013-07-09)
# (test case : D_1000202127)
# =================================================================

import math
import operator
import util
import space_group_cif
import parse
import cifparse as cif


###############################################################################
def contact(file):
    """calculate close contact with grid method check the NCS matrix if exist."""

    if not util.check_file(100, file):
        print("Error: file (%s) does not exist" % file)
        return

    atominfo = get_atominfo(file)

    #    expand_sym_cello(atominfo) #testing

    print("All close contacts of atoms  in the file =%s" % file)
    _netdis = check_dis(atominfo, 0)  # noqa: F841

    if atominfo["mtrix"]:  # do extra for atoms by mtrix
        print("\nClose contacts of atoms generated by matrix in file=%s" % file)
        atominfo_mtr = atom_by_mtrix(atominfo, atominfo["mtrix"])
        _netdis = check_dis(atominfo_mtr, 0)  # noqa: F841


###############################################################################
def shift_xyz_into_unitcell(file, outfile):
    """Shift the asu into the unit. file is a PDB file!"""

    if not outfile:
        outfile = file + "_shifted"

    info = get_atominfo(file)

    if not info["cell"]:
        print("Error: The unit cell is not extracted! check you xyz file.\n")
        return

    fw = open(outfile, "w")
    _frac, orth = util.frac_orth_matrix(info["cell"])  # get conversion matrix
    xf, yf, zf = info["xf"], info["yf"], info["zf"]
    xfn, yfn, zfn = shift_xyz2unit(xf, yf, zf)

    nxf = len(xf)

    fp = open(file, "r").readlines()

    anis = {}
    for x in fp:
        if "ATOM" in x[:4] or "HETA" in x[:4]:
            anis[x[12:26]] = []
        if "ANISOU" in x[:6]:
            anis[x[12:26]] = x[26:]
    for x in fp:  # header
        if "ATOM" in x[:4] or "HETA" in x[:4]:
            break
        fw.write(x)
    sp = " "
    for i in range(nxf):
        xff, yff, zff = xfn[i], yfn[i], zfn[i]
        xno = util.matrix_prod(orth, [xff, yff, zff])  # convert franck back to orth.
        group, natm, atom_o = info["group"][i], info["natm"][i], info["atom_o"][i]
        alt, comp, ch = info["alt"][i], info["comp"][i], info["chain"][i]
        nres, ins, segid = info["nres"][i], info["ins"][i], info["segid"][i]
        occ, biso, symbol = float(info["occ"][i]), float(info["biso"][i]), info["symbol"][i]
        if "." in alt:
            alt = " "
        if "." in ins:
            ins = " "
        ss = "%-6s%5s %4s%1s%3s%2s%4d%1s   %8.3f%8.3f%8.3f%6.2f%6.2f%4s  %4s%2s  \n" % (
            group,
            natm,
            atom_o,
            alt,
            comp,
            ch,
            nres,
            ins,
            xno[0],
            xno[1],
            xno[2],
            occ,
            biso,
            sp,
            segid,
            symbol,
        )
        fw.write(ss)
        id = "%4s%1s%3s%2s%4d" % (atom_o, alt, comp, ch, nres)  # pylint: disable=redefined-builtin
        if anis[id]:
            ss1 = "ANISOU%5s %s%s" % (natm, id, anis[id])
            fw.write(ss1)

    fpr = reversed(fp)
    for x in fpr:
        if "ATOM" in x[:4] or "HETA" in x[:4]:
            break
        fw.write(x)

    fw.close()
    print("The new PDB file = %s\n" % outfile)


###############################################################################
def check_special_position(file, outfile, out_xyz):
    """file can be in PDB/mmCIF format.
    the tolerance of distanc for 0.25 for refmac, 0.5 for shelx, 1.0 for phenix.
    """

    if not outfile:
        outfile = file + "_occ"
    fw = open(outfile, "w")

    # dist_limit = 0.5  # the minimum distance for atoms on special positions
    extend = 2

    info = get_atominfo(file)
    print("Searching atoms on special positions(space group=%s).." % info["spg"])

    if not info["cell"]:
        t = "Error: the unit cell is not extracted!\n"
        fw.write(t)
        fw.close()
        return

    frac, _orth = util.frac_orth_matrix(info["cell"])  # get conversion matrix
    m1, m2, m3 = get_sym_operator(info, "frac")  # get sym

    xf, yf, zf = info["xf"], info["yf"], info["zf"]
    xfn, yfn, zfn = shift_xyz2unit(xf, yf, zf)
    # xfc,yfc,zfc=xyz_orig(xf, yf, zf)
    # xfc1,yfc1,zfc1=xyz_orig(xfn, yfn, zfn)
    # print 'new orig=%.3f %.3f %.3f ; old orig=%.3f %.3f %.3f' %(xfc1,yfc1,zfc1,xfc,yfc,zfc)

    xfb = util.matrix_prod(frac, [extend, extend, extend])  # boundary in frac
    xmin, xmax = expand_boundary(xfn, yfn, zfn, xfb)  # use the shifted
    #  print xmin, xmax
    d = 0
    nspecial = []
    box = (-3, -2, -1, 0, 1, 2, 3)  # 7*7*7=125 cell
    #   box=( -2, -1, 0, 1 ,2)  #5*5*5=125 cell
    #    box=( -1, 0, 1) #3*3*3=27
    nop = len(m1)
    for ii in box:
        for jj in box:
            for kk in box:
                for j in range(nop):  # number of operators
                    m10, m20, m30 = m1[j][0], m2[j][0], m3[j][0]  # pre-assign 30% faster
                    m11, m21, m31 = m1[j][1], m2[j][1], m3[j][1]
                    m12, m22, m32 = m1[j][2], m2[j][2], m3[j][2]
                    m13, m23, m33 = m1[j][3], m2[j][3], m3[j][3]
                    nxf = len(xf)
                    for i in range(nxf):
                        xi = [xfn[i], yfn[i], zfn[i]]  # shifted frac
                        x, y, z = xfn[i], yfn[i], zfn[i]
                        xnf0 = m10 * x + m11 * y + m12 * z + m13 + ii
                        xnf1 = m20 * x + m21 * y + m22 * z + m23 + jj
                        xnf2 = m30 * x + m31 * y + m32 * z + m33 + kk

                        if xnf0 < xmin[0] or xnf0 > xmax[0] or xnf1 < xmin[1] or xnf1 > xmax[1] or xnf2 < xmin[2] or xnf2 > xmax[2]:
                            continue

                        d = util.distf(xi, [xnf0, xnf1, xnf2], info["cell"])
                        #   if d>0.5 : continue
                        #    xno = util.matrix_prod(orth,[xnf0,xnf1,xnf2])
                        scode = "%d%d%d" % (ii + 5, jj + 5, kk + 5)
                        if d < 0.5 and (j != 0 or "555" not in scode):  # atom on special position
                            s1 = "%s_%s_%s_%s_%s_%s_%s_%d" % (
                                info["chain"][i],
                                info["comp"][i],
                                info["nres"][i],
                                info["atom"][i],
                                info["alt"][i],
                                info["ins"][i],
                                info["natm"][i],
                                i,
                            )
                            s2 = "%3d %s %d %.3f" % (info["mtr"][i], scode, j + 1, d)
                            nspecial.append([s1, s2])

    if not nspecial:
        print("\nNote: No atoms sit on special position.\n")
        # Disable writing to logfile
        # fw.write('\nNote: No atoms sit on special position.\n')
        return

    t = "\nNote: The following atoms sit on special position.\n"
    print(t)
    fw.write(t)
    nspecial.sort(key=lambda v: v[0])

    dic = {}
    for m, xx in enumerate(nspecial):
        if m > 0 and nspecial[m][0] == nspecial[m - 1][0]:
            dic[xx[0]].append(xx[1])
        else:
            dic[xx[0]] = [xx[1]]

    swater, l_occ = [], []
    for s in sorted(dic.keys()):
        nfold = len(dic[s]) + 1
        op = ["555 1"]  # the first one
        for m in dic[s]:
            t = m.split()
            op.append("%s %s" % (t[1], t[2]))

        occ, ss = check_coord_occ(info, s, nfold)
        s1 = s.split("_")
        s2 = "_".join(s1[:-1])
        t = "\natom id=%s : symmetry fold=%d \n" % (s2, nfold)

        if "_" not in s:
            continue
        na = int(s.split("_")[-1])
        occ_orig = info["occ"][na]
        print("%s sym_code=%s occ_orig=%s" % (t.strip(), op, occ_orig))
        print(ss)

        if ("_HOH_" in ss or "_DOD_" in ss) and float(occ_orig) == 1:
            swater.append(s1[:-1])
            l_occ.append(occ)

        if "Wrong occupancy" in ss:
            fw.write(t)
            fw.write(ss)

    fw.close()

    if l_occ and util.is_cif(file):
        update_coord(file, swater, l_occ, out_xyz)
        print("%d waters are updated with occupancy in the coordinates." % len(l_occ))
        print("New coordinate= %s" % out_xyz)
    else:
        print("Coordinates are not updated (Reason: either not in cif or OCC not 1.00).")

    print("\nThe output file =%s\n" % outfile)


##################################################################
def check_coord_occ(info, id, nfold):  # pylint: disable=redefined-builtin
    """From symmetry fold to occupancy"""

    occ = {2: 0.5, 3: 0.33, 4: 0.25, 6: 0.16}

    t = id.split("_")
    na = int(t[-1])  # atom number
    ss = "?"
    atom = "(%s : id=%s_%s_%s)" % (info["atom"][na], info["chain"][na], info["comp"][na], info["nres"][na])

    if info["occ"][na] < 0.0 or info["occ"][na] > 1.0:
        ss = "Error: Wrong occupancy of %.2f for atom %s.\n" % (info["occ"][na], atom)
    elif 1.0 / nfold < info["occ"][na] < 1.0:
        ss = "Warning: Wrong occupancy of %.2f for atom %s.\n" % (info["occ"][na], atom)
    elif info["occ"][na] == 1.0:
        ss = "Error: Wrong occupancy of %.2f for atom %s, change to (%.2f).\n" % (info["occ"][na], atom, occ[nfold])

    # """

    # if (occ[nfold] < info['occ'][na]) :
    #     if info['occ'][na] >=1.0:
    #         ss='Error: Wrong occupancy for atom (%s : id=%s_%s_%s). change to (%.2f)\n' %(info['atom'][na], info['chain'][na],info['comp'][na], info['nres'][na], occ[nfold])

    #     else:
    #         ss='Warning: Wrong occupancy for atom (%s : id=%s_%s_%s).\n' %(info['atom'][na], info['chain'][na],info['comp'][na], info['nres'][na])
    # """
    return occ[nfold], ss


##################################################################
def update_coord(file, swater, occ, out_xyz):
    """ """

    print("Updating coordinate..\n")

    newfile = file + "_new"
    if len(out_xyz):
        newfile = out_xyz
    fw = open(newfile, "w")

    fp = open(file, "r")
    flist = []
    for x in fp:
        if x.strip() == 0:
            continue
        flist.append(x.lstrip())
    fp.close()

    flist = open(file, "r").readlines()

    n1 = 0
    for i, x in enumerate(flist):  # get the first, part.
        if "loop_" in x[:5] and "_atom_site." in flist[i + 1][:11] and "_atom_site." in flist[i + 2][:11]:
            n1 = i
            break

    sflist = []
    n2 = len(flist)
    for i in range(n1, n2):  # get last line of coord. (the second part)
        sflist.append(flist[i])
        t = flist[i].lstrip()
        if "#" in t[:1] or "data_" in t[:5] or ("_" in t[:1] and "_atom_site." not in t[:11]):
            n2 = i
            break

    for i in range(0, n1):
        fw.write(flist[i])  # write the front part

    items, values = cif.cifparse(flist[n1:n2], "_atom_site.")

    ch_col = items.index("_atom_site.auth_asym_id")
    comp_col = items.index("_atom_site.label_comp_id")
    nres_col = items.index("_atom_site.auth_seq_id")
    atom_col = items.index("_atom_site.label_atom_id")
    alt_col = items.index("_atom_site.label_alt_id")
    ins_col = items.index("_atom_site.pdbx_PDB_ins_code")
    natm_col = items.index("_atom_site.id")
    occ_col = items.index("_atom_site.occupancy")

    # swater=[ch, comp,nres,atom,alt,ins,natom]
    rows = cif.get_rows(items, values)
    for i in range(len(rows)):
        for j, x in enumerate(swater):
            if (
                rows[i][ch_col] == x[0]
                and rows[i][comp_col] == x[1]
                and rows[i][nres_col] == x[2]
                and rows[i][atom_col] == x[3]
                and rows[i][alt_col] == x[4]
                and rows[i][ins_col] == x[5]
                and rows[i][natm_col] == x[6]
            ):
                rows[i][occ_col] = "%.2f" % occ[j]
                break

    cif.write_cif_loop(fw, items, rows)
    for i in range(n2, len(flist)):
        fw.write(flist[i])  # write the end part

    fw.close()

    return newfile


##################################################################
def assign_alt_id(file, outfile):
    """assign alt id if it is wrong!"""

    info = get_atominfo(file)
    netdis = check_dis(info, 1)  # dist for alt conformers

    atoms = []
    for x in netdis:
        atoms.append(x[1])
        atoms.append(x[2])
    atoms.sort()
    uatoms = []
    for i, x in enumerate(atoms):
        if i > 0 and x == atoms[i - 1]:
            continue
        uatoms.append(x)

    satom, altidd = [], []
    for i, x in enumerate(uatoms):
        t = x.split("_")
        if i > 0:
            t0 = uatoms[i - 1].split("_")
            if t[:4] != t0[:4]:
                util.gsort(satom, 1, -1)
                altid = check_alt(satom)
                if altid:
                    altidd.append(altid)
                # print satom
                satom = []
        satom.append([x, info["occ"][int(t[7])]])

    if len(altidd):
        if util.is_cif(file):
            newfile = update_ciffile(file, altidd)
        else:
            newfile = update_pdbfile(file, altidd)

        if outfile:
            util.move(newfile, outfile)
            print("\nThe updated new file = %s\n" % outfile)
        else:
            print("\nThe updated new file = %s\n" % newfile)


##################################################################
def update_pdbfile(file, altidd):
    """correct alter conformer IDs if it is wrong."""

    nfile = file + "_new_alt"
    fw = open(nfile, "w")

    flist = open(file, "r").readlines()

    atom = []
    n = 0
    for i, x in enumerate(flist):
        if "ATOM" in x[:4] or "HETA" in x[:4]:
            atom.append([i, n])
            n = n + 1
        else:
            atom.append([i, -1])

    alt = {}
    for x in altidd:  # put in a dic
        for y in x:
            alt[y[0]] = y[1]

    for i, x in enumerate(flist):
        if "ATOM" in x[:4] or "HETA" in x[:4]:
            m = atom[i][1]
            if m > 0 and m in alt.keys():
                y = "".join([x[:16], alt[m], x[17:]])
                fw.write(y)
            else:
                fw.write(x)
        else:
            fw.write(x)

    #    print  len(alt), alt

    fw.close()
    return nfile


##################################################################
def update_ciffile(file, altidd):
    """correct alter conformer IDs if it is wrong."""

    nfile = file + "_new_alt"
    fw = open(nfile, "w")
    flist = open(file, "r").readlines()

    items, values = cif.cifparse(flist, "_atom_site.")  # a loop
    rows = cif.get_rows(items, values)

    nalt = -1
    alt = "_atom_site.label_alt_id"
    if alt in items:
        nalt = items.index(alt)

    if nalt < 0:
        print("Warning: cif token for alt_id is not found, no correction is applied.")
        return nfile

    for x in altidd:  # correct alt_ids
        for y in x:
            n = y[0]  # id = y[1]
            rows[n][nalt] = y[1]

    st, nall = 0, len(flist)
    for i, ln in enumerate(flist):
        if "loop_" in ln.lstrip()[:5] and "_atom_site." in flist[i + 1].lstrip()[:11]:
            st = i
            break
        fw.write(ln)

    for i in range(st, nall):  # remove _atom_site
        if "#" in flist[i].lstrip()[0]:
            st = i
            break

    fw.write("#\nloop_\n")
    for x in items:
        fw.write("%s \n" % x)

    fmt = []  # the writing format
    nrow, ncol = len(rows), len(rows[0])
    for i in range(ncol):  # put column format in a list
        tmp = []
        for j in range(nrow):
            n = len(rows[j][i])
            tmp.append(n)
        fmt.append(max(tmp))

    for x in rows:  # re-write atom_site (left formated)
        for i, y in enumerate(x):
            fw.write(y.ljust(fmt[i] + 1))
        fw.write("\n")

    for n in range(st, nall):  # the last lines.
        fw.write(flist[n])

    fw.close()
    return nfile


##################################################################
def check_alt(satom):
    """check alt conformers and correct if wrong"""

    alt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    nalt = len(alt)
    altsum, atom, altid = 0, [], []

    for i, x in enumerate(satom):
        if i > nalt - 1:
            print("Error: number of alter conformers beyond the setting limit. STOP!")
            break

        altsum = altsum + x[1]
        atom.append(x[0])
        t = x[0].split("_")
        # print x, t[4]
        #        if t[4] != alt[i] :
        if t[4] == ".":
            altid.append([int(t[7]), alt[i]])
            print("warning: new assignment of alter ID (%s->%s) : %s" % (t[4], alt[i], x[0]))

    if altsum > 1:
        print("Error: summation of occupancy (%.2f)>1.00 %s" % (altsum, atom))

    return altid


##################################################################
def get_sym_operator(info, idd):
    """read the text (operator converted to numbers) and convert it to matrix
    m1= x11,x12,x13,t1;  y11,y12,y13,t2; z11,z12,z13,t3;
    m1,m2,m3 the same as (REMARK 290) if applying orthogonal
    """
    spg = info["spg"]
    frac, orth = util.frac_orth_matrix(info["cell"])  # get matrix

    m1, m2, m3 = [], [], []
    spg_text = space_group_cif.text
    tmp = spg_text.split("\n")

    mmf = []
    for x in tmp:
        t = x.split("'")
        if "'" in x and t[1] == spg:
            #        print x
            t1 = [float(y) for y in x[22:].split()]
            tr = [0, 0, 0]
            if t1[10] > 0:
                tr[0] = t1[9] / float(t1[10])
            if t1[12] > 0:
                tr[1] = t1[11] / float(t1[12])
            if t1[14] > 0:
                tr[2] = t1[13] / float(t1[14])
            if idd == "frac":
                m1.append([t1[0], t1[1], t1[2], tr[0]])
                m2.append([t1[3], t1[4], t1[5], tr[1]])
                m3.append([t1[6], t1[7], t1[8], tr[2]])
                continue

            to = util.matrix_prod(orth, tr)
            mmf = [[t1[0], t1[1], t1[2]], [t1[3], t1[4], t1[5]], [t1[6], t1[7], t1[8]]]
            mmo = util.matrix_prod_(orth, mmf)
            mmf = util.matrix_prod_(mmo, frac)
            mmf[0].append(to[0])
            mmf[1].append(to[1])
            mmf[2].append(to[2])

            m1.append(mmf[0])
            m2.append(mmf[1])
            m3.append(mmf[2])
    # print 'final=', m1,m2,m3

    return m1, m2, m3


##################################################################
def xyz_orig(x, y, z):
    n = len(x)
    xc, yc, zc = 0, 0, 0
    if n == 0:
        print("Error: length of data is zero. No origin is calculated.")
        return xc, yc, zc
    for i in range(n):
        xc = xc + x[i]
        yc = yc + y[i]
        zc = zc + z[i]

    return xc / n, yc / n, zc / n


##############################################################
def shift_xyz2unit(x, y, z):
    """Shift the center of the fractional xyz to the unit cell"""

    n = len(x)
    xc, yc, zc = 0, 0, 0

    if n == 0:
        print("Error: length of data is zero. No origin is calculated.")
        return x, y, z
    for i in range(n):
        xc = xc + x[i]
        yc = yc + y[i]
        zc = zc + z[i]

    spand = 0.0
    xc, yc, zc = int(xc / n + spand), int(yc / n + spand), int(zc / n + spand)
    print("Unit cell (a,b,c) shifted = %s %s %s" % (xc, yc, zc))

    if xc == 0 and yc == 0 and zc == 0:
        return x, y, z
    xn, yn, zn = [], [], []
    for i in range(n):
        x1 = x[i] - xc
        y1 = y[i] - yc
        z1 = z[i] - zc

        xn.append(x1)
        yn.append(y1)
        zn.append(z1)

    return xn, yn, zn


##################################################################
def expand_boundary(xo, yo, zo, extend):
    """expand boundary for fractional coordinate"""

    xmin, xmax = [0, 0, 0], [0, 0, 0]
    xmin[0], xmax[0] = min(xo) - extend[0], max(xo) + extend[0]
    xmin[1], xmax[1] = min(yo) - extend[1], max(yo) + extend[1]
    xmin[2], xmax[2] = min(zo) - extend[2], max(zo) + extend[2]

    return xmin, xmax


###############################################################################
def get_atominfo(file):
    """Load atom information (pdb or cif)"""

    atominfo = {
        "chain": [],
        "nres": [],
        "comp": [],
        "atom": [],
        "symbol": [],
        "alt": [],
        "ins": [],
        "x": [],
        "y": [],
        "z": [],
        "xf": [],
        "yf": [],
        "zf": [],
        "occ": [],
        "mtr": [],
        "symop": [],
        "spg": "",
        "cell": [],
        "mtrix": [],
        "atom_o": [],
        "group": [],
        "natm": [],
        "natm_c": [],
        "segid": [],
    }

    # print 'Loading atom information.'
    if not util.check_file(100, file):
        print("Error: file (%s) not exist" % file)
        return atominfo

    if util.is_cif(file):
        dic = data_from_cif(file, atominfo)
    else:
        dic = data_from_pdb(file, atominfo)
    # print 'spg=', dic['spg'], dic['cell']

    atominfo.update(dic)
    return atominfo


###############################################################################
def data_from_cif(file, info):
    """load data to dictionary from mmcif format"""

    flist = open(file, "r").readlines()

    cell = parse.cell(flist)
    spg = parse.space_group_name(flist)
    mtrix = parse.ncs_matrix(flist)
    # scale = parse.scale(flist)
    atom = parse.atom_site(flist)  # return a dic

    info.update(atom)
    info["cell"] = cell
    info["spg"] = spg
    info["mtrix"] = mtrix

    if cell and cell[0] > 1.1:
        frac, _orth = util.frac_orth_matrix(cell)  # get matrix
        n = len(info["x"])
        xf, yf, zf, mtr = [], [], [], []
        for i in range(n):
            xyzf = util.matrix_prod(frac, [info["x"][i], info["y"][i], info["z"][i]])
            xf.append(xyzf[0])
            yf.append(xyzf[1])
            zf.append(xyzf[2])
            mtr.append(1)  # allways 1 for the 1st copy
        info["xf"] = xf
        info["yf"] = yf
        info["zf"] = zf
        info["mtr"] = mtr

    return info


###############################################################################
def data_from_pdb(file, info):
    """load data to dictionary from pdb format"""

    fp = open(file, "r")
    chain, nres, comp, atom, symbol, alt, ins, biso, occ = [], [], [], [], [], [], [], [], []
    group, natm, natm_c, atom_o, segid = [], [], [], [], []
    mtrix, mtr, symop, xf, yf, zf, x, y, z, spg = [], [], [], [], [], [], [], [], [], ""

    cell, spg = [], ""
    for v in fp:  # get header infor
        if v[:6] == "MTRIX1" and "1" not in v[55:].strip():
            mt1 = [float(m) for m in v[10:55].split()]
        elif v[:6] == "MTRIX2" and "1" not in v[55:].strip():
            mt2 = [float(m) for m in v[10:55].split()]
        elif v[:6] == "MTRIX3" and "1" not in v[55:].strip():
            mt3 = [float(m) for m in v[10:55].split()]
            mtrix.append([mt1, mt2, mt3])
        elif "CRYST1" in v[:6]:
            cell = [float(xx) for xx in v.split()[1:7]]
            spg = v[54:65].strip()
        elif "ATOM" in v[:4] or "HETA" in v[:4]:
            break

    frac, _orth = util.frac_orth_matrix(cell)  # get matrix

    fp.seek(0)
    nat = 0
    for v in fp:
        if "ENDMDL" in v[:6]:
            break
        if "ATOM" in v[:4] or "HETA" in v[:4]:
            xx, yy, zz = float(v[30:38]), float(v[38:46]), float(v[46:54])
            oc, bb = float(v[54:60]), float(v[60:66])
            x.append(xx)
            y.append(yy)
            z.append(zz)
            biso.append(bb)
            occ.append(oc)

            if cell and cell[0] > 1.1:  # get the fractional xyz
                xyzf = util.matrix_prod(frac, [xx, yy, zz])
                xf.append(xyzf[0])
                yf.append(xyzf[1])
                zf.append(xyzf[2])

            if v[70:74].strip():
                chain.append(v[70:74].strip())
            else:
                chain.append(v[20:22].strip())

            group.append(v[:6].strip())
            natm.append(v[6:11].strip())
            natm_c.append(nat)
            nres.append(int(v[22:26]))
            comp.append(v[17:20].strip())
            atom.append(v[12:16].strip())
            atom_o.append(v[12:16])
            segid.append(v[72:76])
            symbol.append(v[76:78].strip())
            mtr.append(1)

            if v[16:17] == " ":
                alt.append(".")
            else:
                alt.append(v[16:17])

            if v[26:27] == " ":
                ins.append(".")
            else:
                ins.append(v[26:27])

            nat = nat + 1  # counting the atom/hetatm

    fp.close()

    info = {
        "chain": chain,
        "nres": nres,
        "comp": comp,
        "atom": atom,
        "biso": biso,
        "occ": occ,
        "symbol": symbol,
        "alt": alt,
        "ins": ins,
        "x": x,
        "y": y,
        "z": z,
        "xf": xf,
        "yf": yf,
        "zf": zf,
        "mtr": mtr,
        "symop": symop,
        "spg": spg,
        "cell": cell,
        "mtrix": mtrix,
        "group": group,
        "natm": natm,
        "natm_c": natm_c,
        "atom_o": atom_o,
        "segid": segid,
    }

    return info


##################################################################
def atom_by_mtrix(atominfo, mtrix):
    atominfo_mtr = atominfo.copy()
    natom = len(atominfo["x"])
    for i, mt in enumerate(mtrix):
        for j in range(natom):
            x, y, z = atominfo["x"][j], atominfo["y"][j], atominfo["z"][j]
            xp = mt[0][0] * x + mt[0][1] * y + mt[0][2] * z + mt[0][3]
            yp = mt[1][0] * x + mt[1][1] * y + mt[1][2] * z + mt[1][3]
            zp = mt[2][0] * x + mt[2][1] * y + mt[2][2] * z + mt[2][3]

            atominfo_mtr["chain"].append(atominfo["chain"][j])
            atominfo_mtr["nres"].append(atominfo["nres"][j])
            atominfo_mtr["comp"].append(atominfo["comp"][j])
            atominfo_mtr["atom"].append(atominfo["atom"][j])
            atominfo_mtr["alt"].append(atominfo["alt"][j])
            atominfo_mtr["ins"].append(atominfo["ins"][j])
            atominfo_mtr["x"].append(xp)
            atominfo_mtr["y"].append(yp)
            atominfo_mtr["z"].append(zp)
            atominfo_mtr["mtr"].append(i + 2)
            atominfo_mtr["symbol"].append(i + 2)

    return atominfo_mtr


##################################################################
def check_dis(info, idd):
    """info: a dic holding all atom information;
    idd: 0 for atom contact;  1 assign proper alt id
    """

    chain, nres, comp = info["chain"], info["nres"], info["comp"]
    atom, symbol, alt, ins = info["atom"], info["symbol"], info["alt"], info["ins"]
    x, y, z, mtr = info["x"], info["y"], info["z"], info["mtr"]

    boxsize = 4
    xmin, xmax = min(x) - boxsize, max(x) + boxsize
    ymin, ymax = min(y) - boxsize, max(y) + boxsize
    zmin, zmax = min(z) - boxsize, max(z) + boxsize

    #    check_atom_test(chain, nres, comp, atom, alt, ins, x,y,z) #very slow
    #    return

    natom = len(x)
    print("Number of atoms= %d" % natom)
    print(
        "xmin, xmax =(%.2f %.2f): ymin, ymax =(%.2f %.2f): \
    zmin, zmax =(%.2f %.2f)"
        % (xmin, xmax, ymin, ymax, zmin, zmax)
    )

    nx = int((xmax - xmin) / boxsize) + 1
    ny = int((ymax - ymin) / boxsize) + 1
    nz = int((zmax - zmin) / boxsize) + 1
    print("grid size(nx, ny, nz)= %d %d %d :total boxes=%d" % (nx, ny, nz, nx * ny * nz))

    print("Initializating the dictionary for each grid point.")
    grid = {}
    for i in range(nx):
        for j in range(ny):
            for k in range(nz):
                t = "%d_%d_%d" % (i, j, k)
                grid[t] = []

    print("Loading atom index to the grid points")
    grid_list = []
    for n in range(len(x)):
        dx, dy, dz = x[n] - xmin, y[n] - ymin, z[n] - zmin
        i = int(dx / boxsize)
        j = int(dy / boxsize)
        k = int(dz / boxsize)
        tmp = "%d_%d_%d" % (i, j, k)
        grid_list.append([tmp, n])

    # return

    print("Sorting the grid list, so as to fill in the atoms in each cell quickly.")
    grid_list.sort(key=lambda v: v[0])  # sort the first column

    print("Assigning atom number to the ijk box (one box could have many atoms) ")
    for m, xx in enumerate(grid_list):
        if m == 0:
            grid[xx[0]].append(xx[1])
            continue
        if grid_list[m][0] == grid_list[m - 1][0]:
            grid[xx[0]].append(xx[1])
        else:
            grid[xx[0]].append(xx[1])

    print("Calculate distance, going through non-empty box and the sourounding 26 boxes..")
    #    for x in grid.keys(): print x, grid[x]
    alldis = []
    for xx in grid.keys():  # non-empty
        if not grid[xx]:
            continue
        t = xx.split("_")
        i, j, k = int(t[0]), int(t[1]), int(t[2])
        cell_0, cell_26 = [], []
        for ii in (-1, 0, 1):  # search neighbor atoms
            n1 = i + ii
            if n1 < 0 or n1 > nx:
                continue
            for jj in (-1, 0, 1):
                n2 = j + jj
                if n2 < 0 or n2 > ny:
                    continue
                for kk in (-1, 0, 1):
                    n3 = k + kk
                    if n3 < 0 or n3 > nz:
                        continue
                    tt = "%d_%d_%d" % (n1, n2, n3)

                    if not grid[tt]:
                        continue  # remove empty cell.
                    if ii == 0 and jj == 0 and kk == 0:  # center one
                        cell_0.append(xx)
                    else:
                        cell_26.append(tt)

        atom_cell_0, atom_cell_26 = [], []
        for ijk in cell_0:
            atom_cell_0.extend(grid[ijk])
        for ijk in cell_26:
            atom_cell_26.extend(grid[ijk])

        if idd == 0:  # atom contact
            dis = check_atom(chain, nres, comp, atom, symbol, alt, ins, x, y, z, mtr, atom_cell_0, atom_cell_0, natom)
            alldis.extend(dis)
            dis = check_atom(chain, nres, comp, atom, symbol, alt, ins, x, y, z, mtr, atom_cell_0, atom_cell_26, natom)
            alldis.extend(dis)

        elif idd == 1:  # alt
            dis = check_atom_alt(chain, nres, comp, atom, symbol, alt, ins, x, y, z, mtr, atom_cell_0, atom_cell_0, natom)
            alldis.extend(dis)
            dis = check_atom_alt(chain, nres, comp, atom, symbol, alt, ins, x, y, z, mtr, atom_cell_0, atom_cell_26, natom)
            alldis.extend(dis)

    netdis = []
    alldis.sort(key=lambda y: y[0])  # sort first column

    for n, xx in enumerate(alldis):  # get rid of the duplicate
        if n > 0 and xx[1] == alldis[n - 1][2]:
            continue
        if "_CYS_SG_" in xx[1] and "_CYS_SG_" in xx[2] and 1.7 < xx[0] < 2.3:
            continue

        netdis.append(xx)

    if idd == 1:
        return netdis  # alt

    print("\nNumber of total close contact = %3d  " % len(netdis))
    print("Columns: distance, chain, nres, comp, atomname, alt, ins, matrix")
    for xx in sort_multi_table(netdis, (0, 1)):
        print("d=%.2f : atom1=%-20s : atom2=%-20s " % (xx[0], xx[1], xx[2]))

    #    for xx in netdis: print('d=%.3f : atom1=%-20s : atom2=%-20s '%(xx[0], xx[1], xx[2]))
    return netdis


##################################################################
def sort_multi_table(table, cols):
    """sort a table by multiple columns
    table: a list of lists (or tuple of tuples) where each inner list
           represents a row
    cols:  a list (or tuple) specifying the column numbers to sort by
           e.g. (1,0) would sort by column 1, then by column 0
    """
    for col in reversed(cols):
        table = sorted(table, key=operator.itemgetter(col))
    return table


##################################################################
def check_atom_pair(m, n, atom, d):
    """remove the possible bonded atoms. give different cutoff for the atoms
    making bond angle.
    """

    if atom[n] == "N" and atom[m] == "C" or atom[m] == "N" and atom[n] == "C":
        return 1  # bonded

    elif (
        ((atom[n] == "CA" and atom[m] == "C" or atom[m] == "CA" and atom[n] == "C") and 2.2 < d < 2.6)
        or ((atom[n] == "N" and atom[m] == "CA" or atom[m] == "N" and atom[n] == "CA") and 2.2 < d < 2.6)
        or ((atom[n] == "N" and atom[m] == "O" or atom[m] == "N" and atom[n] == "O") and 1.9 < d < 2.5)
    ):
        return 1  # bond angled atoms

    elif atom[n] == "P" and atom[m] == "O3'" or atom[m] == "P" and atom[n] == "O3'":
        return 1  # bonded

    elif (
        (
            (atom[n] == "OP1" or atom[n] == "OP2")
            and (atom[m] == "O3'" or atom[m] == "O3*")
            or (atom[m] == "OP1" or atom[m] == "OP2")
            and (atom[n] == "O3'" or atom[n] == "O3*")
            and 2.0 < d < 2.6
        )
        or (
            (atom[n] == "O3'" or atom[n] == "O3*")
            and (atom[m] == "O5'" or atom[m] == "O5*")
            or (atom[m] == "O3'" or atom[m] == "O3*")
            and (atom[n] == "O5'" or atom[n] == "O5*")
            and 2.4 < d < 3.2
        )
        or ((atom[n] == "C3'" or atom[n] == "C3*") and (atom[m] == "P") or (atom[m] == "C3'" or atom[m] == "C3*") and (atom[n] == "P") and 2.2 < d < 2.8)
    ):
        return 1  # bond angled atoms

    else:
        return 0


##################################################################
def check_atom(chain, nres, comp, atom, symbol, alt, ins, x, y, z, mtr, atom_cell_1, atom_cell_2, natom):
    """selecting atoms with close distance with cutoff"""

    cutoff = 2.2  # limit
    alldis = []

    for n in atom_cell_1:
        for m in atom_cell_2:
            if abs(x[n] - x[m]) > cutoff or abs(y[n] - y[m]) > cutoff or abs(z[n] - z[m]) > cutoff:
                continue
            n1 = nres[n]  # residue number
            n2 = nres[m]
            if mtr[-1] > mtr[0]:  # matrix exist! Only check matrix generated atoms!
                if mtr[n] == mtr[m]:
                    continue
            else:
                if n1 == n2 and chain[n] == chain[m] and ins[n] == ins[m]:  # same residue
                    continue
                elif n1 == n2 and chain[n] == chain[m] and ins[n] != ins[m]:  # same residue, but diff ins.
                    d = math.sqrt((x[n] - x[m]) ** 2 + (y[n] - y[m]) ** 2 + (z[n] - z[m]) ** 2)
                    if abs(n - m) < 18 and check_atom_pair(n, m, atom, d):  # pylint: disable=arguments-out-of-order
                        continue
                elif chain[n] == chain[m] and abs(n1 - n2) == 1:
                    d = math.sqrt((x[n] - x[m]) ** 2 + (y[n] - y[m]) ** 2 + (z[n] - z[m]) ** 2)
                    if check_atom_pair(n, m, atom, d):  # pylint: disable=arguments-out-of-order
                        continue
                elif (0 < n < natom - 1 and nres[n] != nres[n - 1] and nres[n] != nres[n + 1] and (comp[n] != "HOH" and comp[n] != "DOD")) or (
                    0 < m < natom - 1 and nres[m] != nres[m - 1] and nres[m] != nres[m + 1] and (comp[m] != "HOH" and comp[m] != "DOD")
                ):
                    continue  # sigle atom
            d = math.sqrt((x[n] - x[m]) ** 2 + (y[n] - y[m]) ** 2 + (z[n] - z[m]) ** 2)
            if (symbol[n] == "H" or symbol[n] == "D" or symbol[m] == "H" or symbol[m] == "D") and d > 1.5:
                continue
            atom1 = "%s_%s_%s_%s_%s_%s_%d" % (chain[n], nres[n], comp[n], atom[n], alt[n], ins[n], mtr[n])
            atom2 = "%s_%s_%s_%s_%s_%s_%d" % (chain[m], nres[m], comp[m], atom[m], alt[m], ins[m], mtr[m])
            if d < cutoff:
                alldis.append([d, atom1, atom2])

    return alldis


##################################################################
def check_atom_alt(chain, nres, comp, atom, symbol, alt, ins, x, y, z, mtr, atom_cell_1, atom_cell_2, natom):  # pylint: disable=unused-argument
    """selecting atoms with close distance with cutoff"""

    alldis = []
    for n in atom_cell_1:
        for m in atom_cell_2:
            # if abs(x[n]-x[m])==0 and abs(y[n]-y[m])==0 and abs(z[n]-z[m])==0 : continue
            n1 = nres[n]  # residue number
            n2 = nres[m]
            if not (n1 == n2 and atom[n] == atom[m]):
                continue

            d = math.sqrt((x[n] - x[m]) ** 2 + (y[n] - y[m]) ** 2 + (z[n] - z[m]) ** 2)
            if (symbol[n] == "H" or symbol[n] == "D" or symbol[m] == "H" or symbol[m] == "D") and d > 1.5:
                continue
            if d == 0:
                continue
            atom1 = "%s_%s_%s_%s_%s_%s_%d_%d" % (chain[n], nres[n], comp[n], atom[n], alt[n], ins[n], mtr[n], n)
            atom2 = "%s_%s_%s_%s_%s_%s_%d_%d" % (chain[m], nres[m], comp[m], atom[m], alt[m], ins[m], mtr[m], m)
            # print atom1, atom2
            alldis.append([d, atom1, atom2])

    return alldis


# ===============functions below are not /less used ============
##################################################################
def check_atom_test(chain, nres, comp, atom, alt, ins, x, y, z):
    # testing the silly way (huge slow)
    for n in range(len(x)):
        for m in range(len(x)):
            n1 = nres[n]
            n2 = nres[m]
            if m == n or (chain[n] == chain[m] and (n1 - n2 < 1 or n2 - n1 < 1)):
                continue
            else:
                d = math.sqrt((x[n] - x[m]) ** 2 + (y[n] - y[m]) ** 2 + (z[n] - z[m]) ** 2)
                if d < 2.3:
                    print(
                        "d=%.2f : atom1=%s_%s_%s_%s_%s_%s : atom2=%s_%s_%s_%s_%s_%s"
                        % (d, chain[n], nres[n], comp[n], atom[n], alt[n], ins[n], chain[m], nres[m], comp[m], atom[m], alt[m], ins[m])
                    )


##################################################################
def check_atom_fes(chain, nres, comp, atom, symbol, alt, ins, x, y, z, mtr, atom_cell_1, atom_cell_2, natom):  # pylint: disable=unused-argument
    """selecting atoms with close distance with cutoff (tmp)"""

    cutoff = 4.0  # limit
    alldis = []

    for n in atom_cell_1:
        for m in atom_cell_2:
            if abs(x[n] - x[m]) > cutoff or abs(y[n] - y[m]) > cutoff or abs(z[n] - z[m]) > cutoff:
                continue
            n1 = nres[n]  # residue number
            n2 = nres[m]
            if mtr[-1] > mtr[0]:  # matrix exist! Only check matrix generated atoms!
                if mtr[n] == mtr[m]:
                    continue
            else:
                if (("FES" in comp[n] and "FES" in comp[m]) or ("FES" in comp[m] and "FES" in comp[n])) and (
                    ("S" in atom[n] and atom[m][0] == "S")
                    or ("S" in atom[m][0] and "S" in atom[n][0])
                    or ("FE" in atom[n] and "FE" in atom[m])
                    or ("FE" in atom[m] and "FE" in atom[n])
                ):
                    d = math.sqrt((x[n] - x[m]) ** 2 + (y[n] - y[m]) ** 2 + (z[n] - z[m]) ** 2)

                    atom1 = "%s_%s_%s_%s_%s_%s_%d" % (chain[n], nres[n], comp[n], atom[n], alt[n], ins[n], mtr[n])
                    atom2 = "%s_%s_%s_%s_%s_%s_%d" % (chain[m], nres[m], comp[m], atom[m], alt[m], ins[m], mtr[m])
                    if 0.1 < d < 3.5:
                        alldis.append([d, atom1, atom2])

                elif ("FES" in comp[n] or "FES" in comp[m]) and ("FE" in atom[n] or "FE" in atom[m]) and n1 != n2:
                    if abs(x[n] - x[m]) > 4 or abs(y[n] - y[m]) > 4 or abs(z[n] - z[m]) > 4:
                        continue
                    d = math.sqrt((x[n] - x[m]) ** 2 + (y[n] - y[m]) ** 2 + (z[n] - z[m]) ** 2)

                    atom1 = "%s_%s_%s_%s_%s_%s_%d" % (chain[n], nres[n], comp[n], atom[n], alt[n], ins[n], mtr[n])
                    atom2 = "%s_%s_%s_%s_%s_%s_%d" % (chain[m], nres[m], comp[m], atom[m], alt[m], ins[m], mtr[m])
                    if 0.1 < d < 3.5:
                        alldis.append([d, atom1, atom2])
                else:
                    continue

    return alldis


##################################################################
def expand_sym_cello(info):
    """using the orthogonal coord! (not used)"""

    xf = info["xf"]
    xo, yo, zo = info["x"], info["y"], info["z"]

    boxsize = 5

    print("The space group = %s" % info["spg"])

    #    m1,m2,m3=get_sym_operator(info, 'frac')
    m1, m2, m3 = get_sym_operator(info, "orth")

    frac, orth = util.frac_orth_matrix(info["cell"])  # get matrix

    xmin, xmax = min(xo) - boxsize, max(xo) + boxsize
    ymin, ymax = min(yo) - boxsize, max(yo) + boxsize
    zmin, zmax = min(zo) - boxsize, max(zo) + boxsize

    for i in range(len(yo)):  # going through each atom
        xi = [info["x"][i], info["y"][i], info["z"][i]]

        for ii in (-1, 0, 1):
            for jj in (-1, 0, 1):
                for kk in (-1, 0, 1):
                    scode = "%d%d%d" % (ii + 5, jj + 5, kk + 5)

                    for j in range(len(m1)):
                        xo0 = m1[j][0] * xi[0] + m1[j][1] * xi[1] + m1[j][2] * xi[2] + m1[j][3]
                        xo1 = m2[j][0] * xi[0] + m2[j][1] * xi[1] + m2[j][2] * xi[2] + m2[j][3]
                        xo2 = m3[j][0] * xi[0] + m3[j][1] * xi[1] + m3[j][2] * xi[2] + m3[j][3]
                        xf = util.matrix_prod(frac, [xo0, xo1, xo2])
                        xf[0] = xf[0] + ii
                        xf[1] = xf[1] + jj
                        xf[2] = xf[2] + kk

                        xno = util.matrix_prod(orth, [xf[0], xf[1], xf[2]])
                        if xno[0] < xmin or xno[0] > xmax or xno[1] < ymin or xno[1] > ymax or xno[2] < zmin or xno[2] > zmax:
                            continue
                        # print xo, xno
                        d = math.sqrt((xi[0] - xno[0]) ** 2 + (xi[1] - xno[1]) ** 2 + (xi[2] - xno[2]) ** 2)
                        if d > 0.7:
                            continue
                        if info["nres"][i] == 2408:
                            print("2408=%s %s" % (d, scode))
                        if ii == 0 and jj == 0 and kk == 0:
                            continue

                        # nop = j
                        print(
                            "ATOM  %5d %4s%1s%3s %1s%4s%1s   %8.3f%8.3f%8.3f%6.2f%6.2f%3d %s %.3f"
                            % (
                                1,
                                info["atom"][i],
                                info["alt"][i],
                                info["comp"][i],
                                info["chain"][i],
                                info["nres"][i],
                                info["ins"][i],
                                xno[0],
                                xno[1],
                                xno[2],
                                0,
                                0,
                                info["mtr"][i],
                                scode,
                                d,
                            )
                        )
